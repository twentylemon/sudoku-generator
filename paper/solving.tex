% COSC 4P03 Project
% sudoku generator
% Taras Mychaskiw

\section{Sudoku Solving Strategies}

    Generating sudoku puzzles inherently requires being able to solve them. More specifically, the solver must be able to
    check the formity of the sudoku puzzle and hopefully do it very quickly. Several solving strategies are used in the generation
    in hopes that one will outperform the others and speed the generation process. Note that each of the algorithms described below
    detail how to solve a puzzle, not how to get the formity of it. However, the algorithm to get the formity is only a slight
    modification. For example, one could increment a counter keeping track of how many solutions there have been so far once
    a solution is found instead of returning the solution right away.

    \subsection{Backtracking}
    Backtracking is the easiest solving strategy to understand. As the name suggests, it uses backtracking to solve the sudoku puzzle.
    Algorithm~\ref{algo:backtrack} describes the basic idea below. Essentially, the algorithm goes through each cell in the sudoku and
    tries assigning each possible value in a depth first search. If it finds a solution, the solved sudoku is returned right away. If
    some candidate selection leads to an impossible to solve sudoku, the cell is cleared of it's value and the backtracking tries again
    from the previous cell. To solve a sudoku puzzle using the backtracking algorithm, one would call $backtrack(sudoku, 0)$.
    \begin{center}
    \begin{pseudocode}[framebox]{backtrack}{sudoku, cell}
        \COMMENT{check if the sudoku is solved}                         \\
        \IF cell >= \CALL{getTotalCells}{sudoku} \THEN \RETURN {sudoku} \\
        \COMMENT{if there is already a value here, go to the next cell} \\
        \IF \CALL{hasValue}{sudoku, cell} \THEN
            \CALL{backtrack}{sudoku, cell + 1}                          \\
        \COMMENT{otherwise, try all candidates in depth first search}   \\
        \FOREACH cand \in \CALL{getCandidates}{sudoku, cell} \DO \BEGIN
            sudoku[cell] \GETS cand                                     \\
            board \GETS \CALL{backtrack}{sudoku, cell + 1}              \\
            \IF \CALL{isSolved}{board} \THEN \RETURN {board}            \\
        \END                                                            \\
        sudoku[cell] \GETS nothing                                      \\
        \RETURN {sudoku}~\COMMENT{the sudoku is not solved}
        \label{algo:backtrack}
    \end{pseudocode}
    \end{center}
    %\end{Backtracking}
    
    \subsection{Constraint Propagation}
    Constraint propagation expands on the basic backtracking algorithm. It's more complex than backtracking, but solves sudoku puzzles
    much faster on average. Constraint propagation tries to solve a sudoku puzzle in the same manner that a human would. Each cell on
    the sudoku grid will contain a list of all the candidates to sit in that cell - similar to backtracking but they are used differently.
    Two rules are employed in this solving method:
    \begin{verse}
        (1) If a cell only has one possible value, $eliminate$ the value from the cell's peers \\
        (2) If a unit has only one possible cell for a value, $assign$ the value there
    \end{verse}
    These two rules continue to propagate, for example exercising rule 1 may trigger rule 2, which may trigger rule 1 and so on. Eventually,
    either each cell in the entire puzzle will only have one candidate (in which case the puzzle is solved), or the propagation stops and the
    puzzle is not yet solved. At that point, a version of backtracking will take place. A cell is selected, and one of it's candidate values
    is simply assigned to the cell. If the assumption was incorrect, a backtrack would occur and a different value would be selected for the cell.
    Which cell is selected differs from backtracking in that we choose the most constrained cell. That is, the cell with the fewest number of
    candidates, but more than one candidate, is found and a value is assigned there. This helps to limit potential backtracking. The fewer number
    of possibilities a cell has, the better chance that a random selection will end up being correct. 
    To solve a particular sudoku puzzle, each of the cells that already contain values must be $assigned$, then call $search$.
    Algorithms~\ref{algo:assign} through~\ref{algo:clp} describe the flow of each function.
    \begin{center}
    \begin{pseudocode}[framebox]{assign}{cell, value}
        \GLOBAL{candidates} \\
        \FOR cand \in candidates[cell] - \{value\} \DO \CALL{eliminate}{cell, cand}
        \label{algo:assign}
    \end{pseudocode}
    \begin{pseudocode}[framebox]{eliminate}{cell, value}
        \GLOBAL{candidates} \\
        candidates[cell] \GETS candidates[cell] - \{value\}         \\
        \IF |candidates[cell]| = 1 \THEN \BEGIN
            v \GETS q \in candidates[cell]                          \\
            \FOR peer \in peers[cell] \DO \CALL{eliminate}{peer, v} \\
        \END                                                        \\
        
        \FOR unit \in units[cell] \DO \BEGIN
            otherCells \GETS \{ s | s \in unit, value \in candidates[s] \}  \\
            \IF |otherCells| = 1 \THEN \BEGIN
                c \GETS q \in otherCells                                    \\
                \CALL{assign}{c, value}
            \END
        \END
        \label{algo:eliminate}
    \end{pseudocode}
    \begin{pseudocode}[framebox]{search}{\emptyset}
        \GLOBAL{candidates} \\
        \IF \exists~set = \emptyset~\forall set \in candidates \THEN \RETURN \FALSE     \\
        \IF |set| = 1, \forall set \in candidates \THEN \RETURN \TRUE                   \\
        cell \GETS c \text{ such that } |candidates[c]| > 1 \AND \text{is minimal}      \\
        \FOR cand \in candidates[cell] \DO \BEGIN
            \CALL{assign}{cell, cand}                   \\
            \IF \CALL{search}{} \THEN \RETURN {solved}
            \ELSE \CALL{revertAssign}{cell, cand}       \\
        \END                                            \\
        \RETURN \FALSE
        \label{algo:clp}
    \end{pseudocode}
    \end{center}
    %\end{Constraint Propagation}
    
    \subsection{Sudoku as an Exact Cover Problem}
        \subsubsection{Exact Cover}
        %\end{Exact Cover}
        
        \subsubsection{Algorithm X}
        %\end{Algorithm X}
        
        \subsubsection{Dancing Links}
        %\end{Dancing Links}
    %\end{Sudoku as an Exact Cover Problem}

%\end{Sudoku Solvung Strategies}
